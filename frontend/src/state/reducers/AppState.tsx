/********************************************************************************
 *                                                                               *
 *   Redux Reducers and React Context API Provider/Consumer for state AppState   *
 *   Generated by ts2redux from Source file ../AppState.ts                       *
 *                                                                               *
 ********************************************************************************/

import * as immer from 'immer';
import { createSelector } from 'reselect';
import { connect } from 'react-redux';
import { IState } from './index';
import * as React from 'react';
import axios from 'axios';

interface Filter {
  hiddenState: string[];
}

/**
 * @redux true
 */
export class AppState {
  project?: any;
  issues?: any[];
  labels?: any[];
  filter: Filter = { hiddenState: ['closed'] };

  async getter(path: string) {
    return (await axios.get(`/api/v1${path}`)).data;
  }

  async initProject() {
    this.project = await this.getter('/project');
  }
  async initIssues() {
    this.issues = await this.getter('/issues');
  }
  async initLabels() {
    this.labels = await this.getter('/labels');
  }

  toggleHiddenState(state: string) {
    const hidden = this.filter.hiddenState;
    const exists = hidden.indexOf(state) !== -1;
    this.filter.hiddenState = exists
      ? hidden.filter(cur => cur !== state)
      : [...hidden, state];
  }

  get filteredIssues(): any[] | undefined {
    return this.issues?.filter(
      issue => !this.filter.hiddenState.find(state => issue.state === state)
    );
  }
}

export interface IContainerPropsMethods {
  getter: (path: string) => any;
  initProject: () => any;
  initIssues: () => any;
  initLabels: () => any;
  toggleHiddenState: (state: string) => any;
}
export interface IAppState {
  project?: any;
  issues?: any[];
  labels?: any[];
  filter: Filter;
}
export const projectSelectorFn = (state: IAppState): any | undefined =>
  state.project;
export const issuesSelectorFn = (state: IAppState): any[] | undefined =>
  state.issues;
export const labelsSelectorFn = (state: IAppState): any[] | undefined =>
  state.labels;
export const filterSelectorFn = (state: IAppState): Filter => state.filter;
export const filteredIssuesSelectorFnCreator = () =>
  createSelector([issuesSelectorFn, filterSelectorFn], (issues, filter) => {
    const o = new AppState();
    o.issues = issues;
    o.filter = filter;
    return o.filteredIssues;
  });
export const filteredIssuesSelector = filteredIssuesSelectorFnCreator();

export interface IContainerPropsState extends IAppState {
  filteredIssues: any[] | undefined;
}
export interface IProps extends IContainerPropsState, IContainerPropsMethods {}

function pick<T, K extends keyof T>(o: T, ...props: K[]) {
  return props.reduce((a, e) => ({ ...a, [e]: o[e] }), {}) as Pick<T, K>;
}
export function mapStateToPropsWithKeys<K extends keyof IContainerPropsState>(
  state: IState,
  keys: K[]
): Pick<IContainerPropsState, K> {
  return pick(state.AppState as IContainerPropsState, ...keys);
}

export const mapStateToProps = (state: IState): IContainerPropsState => {
  return {
    project: state.AppState.project,
    issues: state.AppState.issues,
    labels: state.AppState.labels,
    filter: state.AppState.filter,
    filteredIssues: filteredIssuesSelector(state.AppState),
  };
};

function mapDispatchToPropsWithKeys<K extends keyof IContainerPropsMethods>(
  dispatch: any,
  keys: K[]
): Pick<IContainerPropsMethods, K> {
  return pick(mapDispatchToProps(dispatch), ...keys);
}

export const mapDispatchToProps = (dispatch: any): IContainerPropsMethods => {
  return {
    getter: (path: string) => {
      return dispatch(RAppState.getter(path));
    },
    initProject: () => {
      return dispatch(RAppState.initProject());
    },
    initIssues: () => {
      return dispatch(RAppState.initIssues());
    },
    initLabels: () => {
      return dispatch(RAppState.initLabels());
    },
    toggleHiddenState: (state: string) => {
      return dispatch(RAppState.toggleHiddenState(state));
    },
  };
};

export function ConnectKeys<
  K extends keyof IAppState,
  J extends keyof IContainerPropsMethods
>(keys: K[], methods: J[]) {
  return connect(
    (state: IState) => mapStateToPropsWithKeys(state, keys),
    (dispatch: any) => mapDispatchToPropsWithKeys(dispatch, methods)
  );
}

export const StateConnector = connect(mapStateToProps, mapDispatchToProps);

const initAppState = () => {
  const o = new AppState();
  return {
    project: o.project,
    issues: o.issues,
    labels: o.labels,
    filter: o.filter,
  };
};
const initWithMethodsAppState = () => {
  const o = new AppState();
  return {
    project: o.project,
    issues: o.issues,
    labels: o.labels,
    filter: o.filter,
    getter: o.getter,
    initProject: o.initProject,
    initIssues: o.initIssues,
    initLabels: o.initLabels,
    toggleHiddenState: o.toggleHiddenState,
    filteredIssues: o.filteredIssues,
  };
};

/**
 * @generated true
 */
export class RAppState {
  private _state?: IAppState;
  private _dispatch?: <A extends {}, T extends {}>(action: A) => T;
  private _getState?: () => any;
  constructor(
    state?: IAppState,
    dispatch?: (action: any) => any,
    getState?: () => any
  ) {
    this._state = state;
    this._dispatch = dispatch;
    this._getState = getState;
  }
  get project(): any | undefined {
    if (this._getState) {
      return this._getState().AppState.project;
    } else {
      if (this._state) {
        return this._state.project;
      }
    }
    return undefined;
  }
  set project(value: any | undefined) {
    if (this._state && typeof value !== 'undefined') {
      this._state.project = value;
    } else {
      // dispatch change for item project
      if (this._dispatch) {
        this._dispatch({
          type: AppStateEnums.AppState_project,
          payload: value,
        });
      }
    }
  }
  get issues(): any[] | undefined {
    if (this._getState) {
      return this._getState().AppState.issues;
    } else {
      if (this._state) {
        return this._state.issues;
      }
    }
    return undefined;
  }
  set issues(value: any[] | undefined) {
    if (this._state && typeof value !== 'undefined') {
      this._state.issues = value;
    } else {
      // dispatch change for item issues
      if (this._dispatch) {
        this._dispatch({ type: AppStateEnums.AppState_issues, payload: value });
      }
    }
  }
  get labels(): any[] | undefined {
    if (this._getState) {
      return this._getState().AppState.labels;
    } else {
      if (this._state) {
        return this._state.labels;
      }
    }
    return undefined;
  }
  set labels(value: any[] | undefined) {
    if (this._state && typeof value !== 'undefined') {
      this._state.labels = value;
    } else {
      // dispatch change for item labels
      if (this._dispatch) {
        this._dispatch({ type: AppStateEnums.AppState_labels, payload: value });
      }
    }
  }
  get filter(): Filter {
    if (this._getState) {
      return this._getState().AppState.filter;
    } else {
      if (this._state) {
        return this._state.filter;
      }
    }
    throw new Error('Invalid State in AppState_filter');
  }
  set filter(value: Filter) {
    if (this._state && typeof value !== 'undefined') {
      this._state.filter = value;
    } else {
      // dispatch change for item filter
      if (this._dispatch) {
        this._dispatch({ type: AppStateEnums.AppState_filter, payload: value });
      }
    }
  }

  async getter(path: string) {
    return (await axios.get(`/api/v1${path}`)).data;
  }

  public static getter(path: string) {
    return (dispatcher: any, getState: any) => {
      return new RAppState(undefined, dispatcher, getState).getter(path);
    };
  }
  async initProject() {
    this.project = await this.getter('/project');
  }

  public static initProject() {
    return (dispatcher: any, getState: any) => {
      return new RAppState(undefined, dispatcher, getState).initProject();
    };
  }
  async initIssues() {
    this.issues = await this.getter('/issues');
  }

  public static initIssues() {
    return (dispatcher: any, getState: any) => {
      return new RAppState(undefined, dispatcher, getState).initIssues();
    };
  }
  async initLabels() {
    this.labels = await this.getter('/labels');
  }

  public static initLabels() {
    return (dispatcher: any, getState: any) => {
      return new RAppState(undefined, dispatcher, getState).initLabels();
    };
  }
  toggleHiddenState(state: string) {
    if (this._state) {
      const hidden = this.filter.hiddenState;
      const exists = hidden.indexOf(state) !== -1;
      this.filter.hiddenState = exists
        ? hidden.filter(cur => cur !== state)
        : [...hidden, state];
    } else {
      if (this._dispatch) {
        this._dispatch({
          type: AppStateEnums.AppState_toggleHiddenState,
          payload: state,
        });
      }
    }
  }

  public static toggleHiddenState(state: string) {
    return (dispatcher: any, getState: any) => {
      return new RAppState(undefined, dispatcher, getState).toggleHiddenState(
        state
      );
    };
  }
}

export const AppStateEnums = {
  AppState_project: 'AppState_project',
  AppState_issues: 'AppState_issues',
  AppState_labels: 'AppState_labels',
  AppState_filter: 'AppState_filter',
  AppState_toggleHiddenState: 'AppState_toggleHiddenState',
};

export const AppStateReducer = (
  state: IAppState = initAppState(),
  action: any
) => {
  return immer.produce(state, (draft: IAppState) => {
    switch (action.type) {
      case AppStateEnums.AppState_project:
        new RAppState(draft).project = action.payload;
        break;
      case AppStateEnums.AppState_issues:
        new RAppState(draft).issues = action.payload;
        break;
      case AppStateEnums.AppState_labels:
        new RAppState(draft).labels = action.payload;
        break;
      case AppStateEnums.AppState_filter:
        new RAppState(draft).filter = action.payload;
        break;
      case AppStateEnums.AppState_toggleHiddenState:
        new RAppState(draft).toggleHiddenState(action.payload);
        break;
    }
  });
};
/********************************
 * React Context API component   *
 ********************************/
export const AppStateContext = React.createContext<IProps>(
  initWithMethodsAppState()
);
export const AppStateConsumer = AppStateContext.Consumer;
let instanceCnt = 1;
export class AppStateProvider extends React.Component {
  public state: IAppState = initAppState();
  public lastSetState: IAppState;
  private __devTools: any = null;
  private __selectorfilteredIssues: any = null;
  constructor(props: any) {
    super(props);
    this.lastSetState = this.state;
    this.getter = this.getter.bind(this);
    this.initProject = this.initProject.bind(this);
    this.initIssues = this.initIssues.bind(this);
    this.initLabels = this.initLabels.bind(this);
    this.toggleHiddenState = this.toggleHiddenState.bind(this);
    this.__selectorfilteredIssues = filteredIssuesSelectorFnCreator();
    const devs = window['__REDUX_DEVTOOLS_EXTENSION__']
      ? window['__REDUX_DEVTOOLS_EXTENSION__']
      : null;
    if (devs) {
      this.__devTools = devs.connect({ name: 'AppState' + instanceCnt++ });
      this.__devTools.init(this.state);
      this.__devTools.subscribe((msg: any) => {
        if (msg.type === 'DISPATCH' && msg.state) {
          this.setState(JSON.parse(msg.state));
        }
      });
    }
  }
  public componentWillUnmount() {
    if (this.__devTools) {
      this.__devTools.unsubscribe();
    }
  }
  public setStateSync(state: IAppState) {
    this.lastSetState = state;
    this.setState(state);
  }
  async getter(path: string) {
    return new RAppState(
      undefined,
      (action: any) => {
        const nextState = AppStateReducer(this.lastSetState, action);
        if (this.__devTools) {
          this.__devTools.send(action.type, nextState);
        }
        this.setStateSync(nextState);
      },
      () => ({ AppState: this.lastSetState })
    ).getter(path);
  }
  async initProject() {
    return new RAppState(
      undefined,
      (action: any) => {
        const nextState = AppStateReducer(this.lastSetState, action);
        if (this.__devTools) {
          this.__devTools.send(action.type, nextState);
        }
        this.setStateSync(nextState);
      },
      () => ({ AppState: this.lastSetState })
    ).initProject();
  }
  async initIssues() {
    return new RAppState(
      undefined,
      (action: any) => {
        const nextState = AppStateReducer(this.lastSetState, action);
        if (this.__devTools) {
          this.__devTools.send(action.type, nextState);
        }
        this.setStateSync(nextState);
      },
      () => ({ AppState: this.lastSetState })
    ).initIssues();
  }
  async initLabels() {
    return new RAppState(
      undefined,
      (action: any) => {
        const nextState = AppStateReducer(this.lastSetState, action);
        if (this.__devTools) {
          this.__devTools.send(action.type, nextState);
        }
        this.setStateSync(nextState);
      },
      () => ({ AppState: this.lastSetState })
    ).initLabels();
  }
  toggleHiddenState(state: string) {
    const nextState = immer.produce(this.state, (draft: IAppState) =>
      new RAppState(draft).toggleHiddenState(state)
    );
    if (this.__devTools) {
      this.__devTools.send('toggleHiddenState', nextState);
    }
    this.setStateSync(nextState);
  }
  public render() {
    return (
      <AppStateContext.Provider
        value={{
          ...this.state,
          getter: this.getter,
          initProject: this.initProject,
          initIssues: this.initIssues,
          initLabels: this.initLabels,
          toggleHiddenState: this.toggleHiddenState,
          filteredIssues: this.__selectorfilteredIssues(this.state),
        }}
      >
        {' '}
        {this.props.children}
      </AppStateContext.Provider>
    );
  }
}
